#import "@preview/modern-g7-32:0.1.0": gost, abstract, title-templates

#show: gost.with(
  title-template: title-templates.mai-university-lab,
  performers: (
    (name: "Елисеев П.А.", position: "Студент М3О-221Б-23"),
  ),
  institute: (number: 3, name: "Системы управления, информатика и электроэнергетика"),
  department: (number: 304, name: "Вычислительные машины, системы и сети"),
  report-type: "Архитектура ЭВМ",
  about: ["Представление числовой информации в ЭВМ"],
  bare-subject: true,
  subject: "",
  research: "Вариант №7",
  manager: (name: "Давыдкина Е.А.", position: "Старший преподаватель, инженер кафедры 304"),
  city: "Москва",
  text-size: (default: 13pt),
)

#show "Результат:": set text(weight: "bold")

#set list(marker: [•])

= Системы счисления, используемые в ЭВМ
$i = 7$

$A = 20+i = 20+7 = 27$

$B = 52-i = 52-7 = 45$

== $A_10->(?_2)$

Делим целое число $27$ на основание $2$.
+ $27 / 2 = 13$, остаток: $1$ ($1_2$)
+ $13 / 2$ = 6, остаток: $1$ ($1_2$)
+ $6 / 2$ = 3, остаток: $0$ ($0_2$)
+ $3 / 2$ = 1, остаток: $1$ ($1_2$)
+ $1 / 2$ = 0, остаток: $1$ ($1_2$)
Записываем остатки снизу вверх: $11011_2$

Результат: $27_10$ = $11011_2$

== $A_10 -> (?)_16$
Делим целое число $27$ на основание $16$, запоминаем остатки.
+ 27 / 16 = 1, Остаток: 11 ($B_16$)
+ 1 / 16 = 0, Остаток: 1 ($1_16$)
Записываем остатки снизу вверх: $1B_16$

Результат: $27_10$ = $1B_16$

== $A_2->(?)_16$

Нумеруем число $11011_2$ в обратном порядке (n = 4...0) $overbracket(1, 4) overbracket(1, 3) overbracket(0, 2) overbracket(1, 1) overbracket(1, 0)_2$, затем умножаем $2^n$ на цифру числа и складываем:

$11011_2 = 1*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 27_10$

Результат: $11011_2 = 27_10$

== $A_16 -> (?)_10$

По аналогии с переводом из двоичной системы счисления:
$overbracket("1", 1) overbracket("B", 0)_16$.

$1"B"_16 = 1*16^1 + 11*16^0=27_10$

Результат: $1"B"_16 = 27_10$

== $A_2 -> (?)_16$

Делим двоичное число $11011_2$ на тетрады справа налево и дописываем незначащие нули: $overbracket(0001) overbracket(1011)_2$, затем переводим каждую тетраду $t_2 -> t_16$:

$overbracket(0001, 1) overbracket(1011, "B")_2 = 1"B"_16$

Результат: $11011_2 = 27_10$

== $A_16 -> (?)_2$

По аналогии с переводом $A_2 -> (?)_16$ преобразуем каждую шестнадцатеричную цифру в двоичную тетраду:

$1"B"_16 = overbracket(0001, 1) overbracket(1011, "B")_2 = 11011_2$

Результат: $1"B"_16 = 11011_2$

== $B_10 -> (?)_16$

Делим целое число $45$ на основание $16$
+ $45 / 16 = 2$, остаток: $13$ ($D_16$)
+ $2 / 16 = 0$, остаток: $2$ ($2_16$)
Записываем остатки снизу вверх: $2D_16$

Результат: $45_10$ = $2D_16$

== $B_16 -> (?)_2$

По аналогии с переводом $A_16 -> A_2$:

$2D_16 = overbracket(2, 0010) overbracket("D", 1101)_16 = 101101_2$

Результат: $2D_16 =  101101_2$

= Прямой, обратный, дополнительный коды
Используем 6 значащих разрядов:

$A = 27 = 00.011011_2"       "B = 45 = 00.101101_2$

== Обратный модифицированный код

Преобразуем в *обратный модифицированный код* отрицательные значения $-A$ и $-B$:

$-A = -27 = 11.100100_2"       "-B = -45 = 11.010010_2$

=== $A-B = A + (-B)$

#align(center)[#table(
  stroke: none,
  columns: 2,
  [$00.011011 (27_10)$], [+], [$11.010010 (-45_10)$], [], [#table.hline()], [$11.101101 (-18)$]
)]
Переполнений не возникло, так как $-18 < |2^6-1|$ и знаковый разряд не равен $10_2$ или $01_2$.

Преобразуем результат в прямой код: $11.010010_2$

Результат: $11.010010_2$

=== $B-A = B + (-A)$

#align(center)[#table(
  stroke: none,
  columns: 2,
  [$00.101101 (45_10$)], [+], [$11.100100 (-27_10$)], [], [#table.hline()], [$00.010001 (17_10)$], [+], [$00.000001 (1_10$)], [], [#table.hline()], [$00.010010 (18_10)$]
)]
Возникла потребность добавить единицу потому что произошёл циклический перенос.

Переполнений не возникло, так как $18 < |2^6-1|$ и знаковый разряд не равен $10_2$ или $01_2$.

Ответ в прямом коде, преобразования не требуются.

Результат: $11.101101_2$

// ---

== Дополнительный модифицированный код

Преобразуем в *дополнительный модифицированный код* отрицательные значения $-A$ и $-B$, прибавив единицу к младшему разряду их *обратного модифицированного кода*:

$-A = -27 => 11.100100_("обр") + 1 = 11.100101_("доп") $
$-B = -45 => 11.010010_("обр") + 1 = 11.010011_("доп") $

Значения $A$ и $B$ в прямом модифицированном коде:

$A = 00.011011_2$

$B = 00.101101_2$

=== $A-B = A + (-B)$

#align(center)[#table(
  columns: 3,
  stroke: none,
  align: right,
  [], $00.011011$, $(+27)$,
  [$+$], $11.010011$, $(-45)$,
  table.hline(),
  [], $11.101110$, []
)]

Знаковые разряды: $11_2$. Переполнения нет ($01$ или $10$ отсутствуют).
Результат отрицательный и представлен в дополнительном модифицированном коде.
Для получения прямого кода модуля выполним операцию взятия дополнительного кода (инверсия + 1):
1. Результат: $11.101110$
2. Инвертируем все биты: $00.010001$
3. Прибавляем 1: $00.010010$
Прямой код результата: $11.010010_2$, что соответствует $-18_{10}$. $(27 - 45 = -18)$.

Результат: $11.101110_2$ (в доп. коде), что равно $11.010010_2$ в прямом коде $(-18_{10})$.

=== $B-A = B + (-A)$

#align(center)[#table(
  columns: 3,
  stroke: none,
  align: right,
  [], $00.101101$, $(+45)$,
  [$+$], $11.100101$, $(-27)$,
  table.hline(),
  [$(1)$], $00.010010$, []
)]

Произошел перенос из знакового разряда, который *отбрасывается* в дополнительном коде (в отличие от обратного).
Знаковые разряды результата: $00_2$. Переполнения нет ($01$ или $10$ отсутствуют).
Результат положительный и представлен в прямом коде.
$00.010010_2$ соответствует $+18_{10}$. $(45 - 27 = 18)$.

Результат: $00.010010_2$ (в прямом коде, $+18_{10}$).

// test

== Переполнение разрядной сетки

Преобразуем в *дополнительный модифицированный  код* значения $A$ и $B$ прибавив единицу к младшему разряду:

$A = 00.011011_2"       "B = 00.101101_2$

=== $A+B = (?)$

#align(center)[#table(
  columns: 3,
  stroke: none,
  align: right,
  [], $00.011011$, $(+27)$,
  [$+$], $00.101101$, $(+45)$,
  table.hline(),
  [], $01.001000$, []
)]

Знаковые разряды: $01_2$. 

Это *признак переполнения* в модифицированных кодах (как $01$, так и $10$).

Результат $27 + 45 = 72$. Максимальное положительное число, представимое 6 битами: $2^6 - 1 = 63$. 

Число $72$ не может быть представлено в данном формате.
Перенос из знакового разряда отсутствует, отбрасывать его не пришлось.

Результат: Переполнение разрядной сетки. Знаковые биты $01$ сигнализируют об ошибке.

= Формы представления чисел в ЭВМ

== Представление чисел с фиксированной точкой

$A = 27$
$(27)_10 = (11011)_2$

Разрядная сетка равна 16 разрядам.

#figure(table(
  columns: (1em, auto, 18em),
  align: center + horizon,
  table.hline(),
  [0], [`000000000011011`], [+27 прямой код],
  table.hline(),
  [1], [`111111111100100`], [-27 обратный код],
  table.hline(),
  [1], [`111111111100101`], [-27 дополнительный код],
  table.hline(),
))
== Представление чисел с плавающей точкой

Разрядная сетка равна 32 разряда, 1 разряд - знак, 7 разрядов – смещенный порядок, 24 разряда – мантисса числа.

Основание системы счисления $P=16$.

Смещение порядка $L=6$, смещенный порядок $P_"см" = P_x + 2^L = P_x + 2^6 = P_x + 64$.

=== $(A,0)$

$(27,0)_10 = (1B,0)_16$

Нормализация: $(1B,0)_16 = 0.1B * 16^2$

$M_x = (0."1B0000")_16$

$P_x = 2$

$P_"см" = P_x + 64 = 2 + 64 = (66)_10 = (42)_16 = (1000010)_2$

#set block(above: 17pt)

#figure(table(
  columns: (3),
  stroke: 1pt,
  align: center,
  [знак], [порядок], [мантисса],
  [0], [`100 0010`], [`0001 1011 0000 0000 0000 0000`],
  [], [$(42)_16$], [1    B    0    0    0    0],
))

=== $(0,A)$

Пример перевода дробной части из десятичной системы счисления в шестнадцатеричную:

$0.27*16 = bold(4).32; 0.32*16=bold(5).12; 0.12*16=bold(1).92; ... $

$(0.27)_10 = (0."451EB8"...)_16$

Нормализация: $(0."451EB8"...) * 16^0$ - не требуется+

$M_x = (0."451EB8")_16$ 

$P_x = 0$

$P_"см" = P_x + 64 = 0 + 64 = (64)_10 = (40)_16 = (1000000)_2$

#figure(table(
  columns: (3),
  stroke: 1pt,
  align: center,
  [знак], [порядок], [мантисса],
  [0], [`100 0000`], [`0100 0101 0001 1110 1011 1000`],
  [], [$(40)_16$], [4    5    1    E    B    8],
))

=== $(A,B)$

$(27, 45)_10 = (1B, 7333...)_16$

Нормализация: $($0.1B7333$...) * 16^2$

$M_x = ($0.1B7333$)_16$ 

$P_x = 2$

$P_"см" = P_x + 64 = 2 + 64 = (66)_10 = (42)_16 = (1000010)_2$

#figure(table(
  columns: (3),
  stroke: 1pt,
  align: center,
  [знак], [порядок], [мантисса],
  [0], [`100 0010`], [`0001 1011 0111 0011 0011 0011`],
  [], [$(42)_16$], [1    B    7    3    3    3],
))

=== $(-A,B)$

$(-27, 45)_10 = -(1B, 7333...)_16$

Нормализация: $-($0.1B7333$...) * 16^2$

$M_x = ($0.1B7333$)_16$

$P_x = 2$

$P_"см" = P_x + 64 = 2 + 64 = (66)_10 = (42)_16 = (1000010)_2$

#figure(table(
  columns: (3),
  stroke: 1pt,
  align: center,
  [знак], [порядок], [мантисса],
  [1], [`100 0010`], [`0001 1011 0111 0011 0011 0011`],
  [], [$(42)_16$], [1    B    7    3    3    3],
))

// Перевод дробной части добавить