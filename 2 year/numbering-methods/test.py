import math

def simpson_rule(func, a, b, n):
    """
    Вычисляет определенный интеграл функции func от a до b
    с использованием составного правила Симпсона с n интервалами.

    Аргументы:
    func (callable): Функция для интегрирования, принимающая один числовой аргумент.
    a (float): Нижний предел интегрирования.
    b (float): Верхний предел интегрирования.
    n (int): Количество подинтервалов. Должно быть четным и >= 2.

    Возвращает:
    float: Приближенное значение интеграла.

    Вызывает:
    ValueError: Если n нечетное или меньше 2.
    """
    if n < 2:
        raise ValueError("Количество интервалов n должно быть >= 2.")
    if n % 2 != 0:
        raise ValueError("Количество интервалов n должно быть четным.")

    h = (b - a) / n
    integral_sum = func(a) + func(b)  # f(x_0) + f(x_n)

    for i in range(1, n):
        x_i = a + i * h
        if i % 2 == 1:  # Нечетные индексы (x_1, x_3, ..., x_{n-1})
            integral_sum += 4 * func(x_i)
        else:  # Четные индексы (x_2, x_4, ..., x_{n-2})
            integral_sum += 2 * func(x_i)

    integral_approximation = (h / 3) * integral_sum
    return integral_approximation

# --- Пример использования ---

# 1. Определим функцию для интегрирования
def my_function(x):
    return x**2  # Интеграл от x^2 dx от 0 до 1 равен 1/3

def another_function(x):
    return math.sin(x) # Интеграл от sin(x) dx от 0 до pi равен 2

def your_problem_function(x):
    # ОСТОРОЖНО: Эта функция имеет проблемы на интервале [-0.8, 0]
    # Знаменатель становится отрицательным или нулем.
    # Для демонстрации правила Симпсона, мы должны использовать функцию,
    # которая хорошо себя ведет на интервале.
    # Например, если бы задача была на другом интервале или с другой функцией:
    try:
        # Пример изначальной задачи, но он не подходит для [-0.8, 0]
        # return 1 / math.sqrt(x + 5 * x**5)
        # Давайте возьмем другую функцию для примера, которая определена
        return 1 / math.sqrt(x + 10) # Просто пример хорошо ведущей себя функции
    except (ValueError, ZeroDivisionError):
        # Обработка случаев, когда x + 5*x**5 <= 0
        # Для численного интегрирования это обычно означает, что метод не применим
        # напрямую или требует специальных подходов (комплексные числа, регуляризация и т.д.)
        # Для простоты вернем очень большое число или NaN, чтобы показать проблему.
        print(f"Предупреждение: Проблема с вычислением f({x})")
        return float('inf') # или float('nan')

if __name__ == "__main__":
    # Пример 1: Интеграл x^2 от 0 до 1 (точный ответ 1/3 = 0.333...)
    a1, b1 = 0, 1
    n1 = 10  # Количество интервалов (четное)
    integral1 = simpson_rule(my_function, a1, b1, n1)
    print(f"Интеграл x^2 от {a1} до {b1} с n={n1}: {integral1:.8f} (Точный: {1/3:.8f})")

    n1_more = 100
    integral1_more = simpson_rule(my_function, a1, b1, n1_more)
    print(f"Интеграл x^2 от {a1} до {b1} с n={n1_more}: {integral1_more:.8f} (Точный: {1/3:.8f})")
    print("-" * 30)

    # Пример 2: Интеграл sin(x) от 0 до pi (точный ответ 2)
    a2, b2 = 0, math.pi
    n2 = 20
    integral2 = simpson_rule(another_function, a2, b2, n2)
    print(f"Интеграл sin(x) от {a2:.2f} до {b2:.2f} с n={n2}: {integral2:.8f} (Точный: {2.0:.8f})")
    print("-" * 30)

    # Пример 3: Попытка с вашей функцией (но на безопасном интервале)
    # Интервал [-0.8, 0] для 1/sqrt(x + 5x^5) вызывает проблемы с действительными числами.
    # Возьмем другой интервал для демонстрации с `your_problem_function` (которая использует 1/sqrt(x+10))
    a3, b3 = 1, 2
    n3 = 4 # Например, n=4 (должно быть четным)
    print(f"Попытка интегрировать your_problem_function (1/sqrt(x+10)) от {a3} до {b3}:")
    try:
        integral3 = simpson_rule(your_problem_function, a3, b3, n3)
        print(f"  Приближенный интеграл с n={n3}: {integral3:.8f}")

        # Для сравнения, можно использовать n побольше
        n3_more = 100
        integral3_more = simpson_rule(your_problem_function, a3, b3, n3_more)
        print(f"  Приближенный интеграл с n={n3_more}: {integral3_more:.8f}")

        # Аналитическое решение для 1/sqrt(x+10) = (x+10)^(-1/2)
        # Первообразная: 2 * (x+10)^(1/2)
        exact_val_3 = 2 * math.sqrt(b3 + 10) - 2 * math.sqrt(a3 + 10)
        print(f"  Точное значение для 1/sqrt(x+10) от {a3} до {b3}: {exact_val_3:.8f}")

    except ValueError as e:
        print(f"  Ошибка: {e}")
    print("-" * 30)

    # Демонстрация ошибки при нечетном n
    try:
        print("Попытка с нечетным n=3:")
        simpson_rule(my_function, 0, 1, 3)
    except ValueError as e:
        print(f"  Ожидаемая ошибка: {e}")